一般来说分布式锁有三种设计思路，**基于数据库**，**基于缓存**，**基于Zookeeper**

## **数据库实现**

使用数据库很简单，只需要设计一张锁表，同时字段都是唯一的。

如果有多个服务想获取锁，只能有一个成功。

存在几个问题：

1. 强依赖数据库可靠性，如果数据库挂了就全完了。

   对此我们可以多加几个主从，增加可靠性

2. 锁没有失效时间。一旦操作失败就会死锁。

   可以用一个定时任务，每隔一段时间就删除一段时间之前的锁

3. 数据库insert失败就会报错

   我们可以使用while循环自旋到上锁成功

4. 数据库锁是不可重入的，很容易死锁。

   增加字段，生成锁的时候也生成线程的id等唯一标志，如果再次上锁发现库里面有同一个线程的锁就直接返回

## 缓存实现

一般是使用`Redis`的一个字段，`setnxex`原子性的设置锁

为了防止释放了别人的锁，要给每一个锁添加一个`UUID`

> 大体的设计思路就是这样：
>
> 同一个资源使用同一个key值，然后value值是每一个操作独有的value，可以随机生成UUID
>
> UUID是为了防止下面的场景：
>
> 操作A获取了锁
>
> 操作A超时
>
> 操作B获取了锁
>
> 操作A完成了操作，释放了锁，但是释放的是B的锁，就寄了

删除锁的时候也注意要原子性的删除，使用`Lua`脚本删除锁

![img](https://cdn.mazhiyong.icu/6e6c98eb-01bf-4102-b362-f3f1c18d1324.png)

参考文章：https://my.oschina.net/u/4499317/blog/5039486

